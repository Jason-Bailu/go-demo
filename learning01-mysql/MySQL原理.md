# MySQL原理

## 存储原理

- **先加载数据到内存中，由CPU执行SQL**
- **缓存预读机制**：读取数据的时候，会多读取相邻的数据放入内存中，一般会直接将4kb的一页读取，Innodb的页单位为16kb
- **每一行的数据都存在一张页数据中**
- **页的数据结构**：User Records / Free Space 存放记录![截屏2024-07-02 11.21.00](./assets/截屏2024-07-02 11.21.00.png)
- **行格式**：默认Dynamic，行的字段也是占用空间，一行最多可以存储65535个字节，如果突破了16kb的页范围就会分页存储，；早期compactor，部分数据+下个页数据地址，链表形式；后面Dyanmic，发展为页内只存储数据存储的地址，这样可以扩大一页的存储数据的数量
- **查询优化：**对于链表的数据，查询的时候效率比较低，所以Innodb为了提高查询效率，它会将数据进行分组，保存相关组记录到**页目录**中，即便链表很长，通过目录数组访问的时候会提高相关查询效率，先比较页目录，再进行组内链表查询
- **分页查询：**对于不同页的查询，会将不同的页号保存在**目录页kv**中，冗余存放**key**：该页内最小主键值，存放**value**：该页内的页号，通过key查找对应的value页，进一步进行相关查询；mysql在存储的时候一页装满了，会**copy**一份第一页，**创建**一份第二页，原本的第一页就会变成一个**目录页**
- 最终所有的数据和索引节点形成一个**B+树**，所有数据存放在叶子结点中，同时所有叶子结点都为**链表**连接起来，索引形成了**聚集**索引，根据主键来排序，有唯一索引、主键，它会默认给你建立一个row_id作为隐藏键索引，如果树的高度太高了，它的查询效率也会降低。
- **B+树的容量：**单个非叶子结点，也就是一页，可以存储1170个kv（页号：指针），高度为2时，可以存储20000条记录，高度为3时，可以存储20000000条记录（默认1k为一条记录）

## 索引原理

- **创建索引：**默认**主键**自带索引和排序，**辅助索引**可以根据自定义添加字段进行联合索引创建，然后在子节点上补充其对应的索引值，但是为了避免辅助索引导致在更新索引时带来的开销，**innodb**则会将辅助索引创建后**记录当前索引对应的数据主键**，从而方便索引更新，然后根据辅助索引再生成一个**辅助索引B+树**，即**辅助索引+主键回表**，辅助索引创建后，如果存在辅助索引不唯一的情况，则会在**内部又保存相关主键**，用于区别相同辅助索引。
- **查询优化器存在：**优化器存在会优化query语句，让它执行**最优的索引进行查询**，索引的查询就是一步一步减少查询的范围，即过滤查询的结果集，一般是从**辅助索引-主键索引-全表扫描**，**注意：**如果通过辅助索引查找的主键索引超过了主键索引的一定量的情况，则会直接走全表扫描，这是最差的情况。
- **索引的匹配规则：**
  - **最左匹配：**查询条件必须从索引的最左侧开始匹配，如果跳过左侧索引，会导致索引失效
  - **精确匹配：**一般使用=等于的精确匹配，也会走索引
  - **范围匹配：**一般就会查询满足该范围的那一列就停止，不会向后继续匹配，因为是排序满足了
  - **全索引匹配：**索引条件中包含了索引的所有列，或者不包含所有列，但索引列包含了查询结果中的所有列
  - **不完全匹配：**也就是不走索引的规则
- **字符集：**正常utf-8字符集默认是0-3个字节表示一个字符，但是存在部分字符需要4个字节来表示，所以mysql提供了**utf8md4**的字符集用0-4个字节表示一个字符，能够表示大部分的字符，注意在排序规则上，**null值<任何值**
- **总结：**
  - **索引列类型尽量小**
  - **利用索引字符串值的前缀**
  - **主键默认自增**
  - **定位并删除表中的重复和冗余索引**
  - **尽量使用覆盖索引进行查询，避免回表带来的性能损耗**

## 事务/锁机制

### 事务

- **事务概念：**一系列操作的组合，开启、DML、保存点、回滚、终止、提交
- **事务特性：ACID**
  - 原子性：事务中的操作不可分割，全部成功/全部失败
  - 一致性：保证数据在事务处理前后一致正确性
  - 隔离性：多个事务并发处理条件下，事务间互不干扰
  - 持久性：事务一旦体检成功就无法回滚/修改，而是永久保留
- **事务提交：**
  - 自动提交：autocommit on 一些DML语句会自动开启事务自动提交，autocommit off 则需要你手动开启提交终止事务
  - 隐式提交：当通过手动开启事务时，在遇到DDL语句也会让事务隐式提交，一般在建表、改表、授权、修改配置等操作时，也会让事务提交
- **事务隔离级别：**
  - 读未提交：一个事务可以读到另一个事务未提交的数据，但存在不可重复读、幻读、脏读
  - 读已提交：一个事务可以读到另一个事务已提交的数据，每次都可以读到新事务提交的修改，但是存在不可重复读、幻读
  - 可重复读：一个事务读取了一条数据，即是其他事务也读取了修改提交了，但该事务读取还是原本数据，可以重复读，但是存在幻读
  - 串行化：最高隔离级别，不允许事务并发操作，对同一条记录的操作只能是串行化执行

### 锁机制

- **读写锁：**
  - 读锁：共享锁、S锁、Shared Lock
  - 写锁：独占锁、X锁、Exclusive Lock
  -  select：不加锁，无论加什么锁，select都可以执行
- **行表锁：**
  - 行锁：
    - 行级锁定允许多个事务同时访问同一表中的不同行，从而提高了并发性。
    - 当一个事务需要修改或者查询某行数据时，它会获取该行的行锁，其他事务需要等待这个行锁释放后才能访问该行。
    - 行锁是MySQL中最细粒度的锁，能够最大程度地支持并发访问。
  - 表锁：
    - 表级锁定会锁定整个表，阻止其他事务对该表的写入操作。
    - 当一个事务需要对表进行修改（如插入、更新、删除）时，它会获取该表的表锁，其他事务需要等待该表锁释放后才能对整个表进行写操作。
    - 表锁是一种比较粗粒度的锁，会限制并发度，因此在高并发环境下可能会引起性能问题。

- **锁机制的使用：**
  - 锁一定在**事务**中使用
  - 加读锁 select 。。。**lock in share mode**
  - 加写锁 select 。。。**for update**
  - 一些写的操作**delete加锁再删除**、**insert隐式锁**、**update如果导致存储结构发生改变则会是删除+插入**的操作，都会**加写锁之后再进行操作**
  - **行锁**：一般指对一行数据进行上锁，对于没有查询的行则会不会上锁
  - **间隙锁**：对于一行记录上下行都会加起来上锁
  - **普通索引**：对检索的行进行锁操作
  - **全表扫描**：也会只对查询的数据进行行锁
  - MVCC多版本控制也为了解决幻读问题
  - **读已提交与可重复读的区别在于**：对于行锁，insert的时候读已提交可以插入，可重复读则无法插入，也是为啥可重复读可以解决幻读的问题
- **加索引的影响：**
  - 索引与行锁：
    - 在MySQL中，通常情况下，使用行级锁来控制并发访问，而行级锁是基于数据行的。
    - 加索引可以提高数据检索的速度，减少查询所需的时间。当某个查询语句在执行时，如果可以利用索引，MySQL会先使用索引定位到满足条件的行，然后对这些行加行级锁。
    - 当数据行被加了行锁后，其他事务需要修改或者查询这些行时，会被阻塞，直到行锁被释放。
  - 索引与表锁：
    - 表级锁是针对整个表的锁定，一般在写入操作时才会被使用。
    - 加索引可以减少对整个表的操作，提高并发性能，因为在有索引的情况下，MySQL在执行写入操作时只需要锁定涉及的数据行，而不是整个表。
    - 因此，加了索引的表在写入操作时更**倾向于使用行级锁而不是表级锁**。
